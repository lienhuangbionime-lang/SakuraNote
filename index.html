<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LifeOS v9.9 (Cloud Neural Link)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Babel Standalone -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; height: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }

        /* Animations */
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-fade-in { animation: fadeIn 0.3s ease-out; }
        
        @keyframes scaleIn { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        .animate-scale-in { animation: scaleIn 0.2s ease-out; }

        @keyframes slideDown { from { transform: translateY(-10px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .animate-slide-down { animation: slideDown 0.2s ease-out forwards; }
        
        .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
    </style>

    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.3.1",
            "react-dom": "https://esm.sh/react-dom@18.3.1",
            "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
            "recharts": "https://esm.sh/recharts@2.13.0?external=react,react-dom",
            "lucide-react": "https://esm.sh/lucide-react@0.454.0?external=react"
        }
    }
    </script>
</head>
<body class="bg-slate-100 text-slate-900">
    <div id="root"></div>

    <!-- Main Application Script (ESM via Babel) -->
    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useMemo, useCallback, memo, useRef } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            LineChart, Line, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer,
            AreaChart, Area, ComposedChart, ReferenceLine
        } from 'recharts';
        import { 
            Save, Download, Upload, Trash2, Activity, Calendar, BookOpen, Brain, Zap, 
            Plus, Wand2, Footprints, Settings, 
            AlertCircle, Network, 
            AlertTriangle, Siren, ShieldAlert, Target, Rocket, PlusCircle,
            Terminal, Copy, Check, X, Clipboard, Sparkles, RefreshCw, Link as LinkIcon, Hash,
            Edit3, Sliders, PlayCircle, StopCircle, Star, MousePointer, Maximize2, Minimize2,
            Anchor, TrendingUp, Heart, Clock, Layers, LayoutGrid, ArrowRight, CornerDownRight,
            Database, Filter, Quote, MoreHorizontal, FileText, ArrowLeft, MapPin, Eye, Menu, GitGraph, Github, Cloud
        } from 'lucide-react';

        // ============================================================================
        // 1. ÂÖ®ÂüüË®≠ÂÆöËàáÂ∏∏Êï∏ (Global Configuration)
        // ============================================================================

        const VERSION = "9.9 (Full Cloud Sync)"; 

        const STORAGE_KEY_LOGS = 'life_os_logs_v8_0'; 
        const STORAGE_KEY_CONFIG = 'life_os_config_v8_0'; 
        const STORAGE_KEY_CCA = 'life_os_cca_v6_5';   
        const STORAGE_KEY_SETTINGS = 'life_os_settings_v6_0'; 
        const STORAGE_KEY_PROMPTS = 'life_os_prompts_v7_2';

        const DEFAULT_METRICS = { mood: 5, focus: 5, energy: 5, deepWork: 0 };
        const DEFAULT_SECTIONS = { summary: '', path: '', drift: '', blindSpot: '' };
        const DEFAULT_GRAPH_SEEDS = { tags: '', links: '', graph: '' };

        const DEFAULT_HABITS = [
            { id: 'reading', label: 'Èñ±ËÆÄ Input', icon: 'BookOpen', active: true },
            { id: 'native_coding', label: 'Native Logic', icon: 'Terminal', active: true },
            { id: 'creation', label: 'Ââµ‰Ωú Output', icon: 'Zap', active: true },
            { id: 'exercise', label: 'ÈÅãÂãï Health', icon: 'Activity', active: true },
            { id: 'meditation', label: 'ÂèçÊÄù Meta', icon: 'Brain', active: true }
        ];

        const DEFAULT_CONFIG = {
            habits: DEFAULT_HABITS,
            targetFocus: 7.0,
            username: "User"
        };

        const DEFAULT_ENTRY = {
            mood: 5, 
            focus: 5, 
            energy: 5, 
            readingTime: 0,
            habits: {}, 
            note: '',
            graphSeeds: { tags: '', links: '', graph: '' }
        };

        const DEFAULT_SETTINGS = {
            avatar: "https://api.dicebear.com/7.x/notionists/svg?seed=Felix",
            username: "MY",
            github: {
                owner: "",
                repo: "",
                token: "",
                branch: "main"
            }
        };

        const DEFAULT_PROMPTS = { monthly: "", daily: "" };

        const BIAS_KEYWORDS = ['Á¢∫Ë™çÂÅèË™§', 'Ê≤âÊ≤íÊàêÊú¨', 'ÈÅéÊì¨Âêà', 'ÁàÜÂÄâ', 'ÊâãÁô¢', 'App Êõø‰ª£Èô™‰º¥', 'Core Weakness', 'ÈÄÉÈÅø'];

        const AlertLevel = { NORMAL: "NORMAL", WARNING: "WARNING", CRITICAL: "CRITICAL", FLAGGED: "FLAGGED" };

        // ============================================================================
        // 2. Èò≤Á¶¶ÊÄßÊ†∏ÂøÉ (Sanitizer Core)
        // ============================================================================

        const sanitizeLogEntry = (entry, index) => {
            const safeDate = entry.date || `1970-01-01_${index}`;
            
            let summary = entry.sections?.summary || '';
            if (typeof entry.note === 'string') {
                let match = entry.note.match(/(?:Day Summary|Summary|Ëà™Ë°åË®òÈåÑ|Êú¨Êó•ÊëòË¶Å|Highlights)\s*[:Ôºö]\s*([^\r\n]+)/i);
                if (!match) {
                    match = entry.note.match(/(?:Day Summary|Summary|Ëà™Ë°åË®òÈåÑ|Êú¨Êó•ÊëòË¶Å|Highlights)\s*[:Ôºö]?\s*[\r\n]+\s*([^\r\n]+)/i);
                }
                if (match && match[1]) {
                    const candidate = match[1].trim();
                    if (candidate.length > 0 && !candidate.startsWith('#') && !candidate.startsWith('>')) {
                        summary = candidate;
                    }
                }
            }

            return {
                date: safeDate,
                timestamp: entry.timestamp || Date.now(),
                metrics: { 
                    mood: Number(entry.metrics?.mood ?? entry.mood ?? 5), 
                    focus: Number(entry.metrics?.focus ?? entry.focus ?? 5), 
                    energy: Number(entry.metrics?.energy ?? entry.energy ?? 5), 
                    deepWork: Number(entry.metrics?.deepWork ?? entry.readingTime ?? 0)
                },
                habits: entry.habits || {},
                note: (typeof entry.note === 'string') ? entry.note : '',
                graphSeeds: {
                    tags: entry.graphSeeds?.tags || '',
                    links: entry.graphSeeds?.links || '',
                    graph: entry.graphSeeds?.graph || ''
                },
                sections: {
                    summary: summary,
                    path: entry.sections?.path || '',
                    drift: entry.sections?.drift || '',
                    blindSpot: entry.sections?.blindSpot || ''
                }
            };
        };

        const sanitizeData = (rawData) => {
            if (!Array.isArray(rawData)) return [];
            return rawData
                .filter(item => item && typeof item === 'object')
                .map(sanitizeLogEntry)
                .sort((a, b) => new Date(a.date) - new Date(b.date));
        };

        const safeLoad = (key, fallback) => {
            if (typeof window === 'undefined') return fallback;
            try {
                const raw = localStorage.getItem(key);
                return raw ? JSON.parse(raw) : fallback;
            } catch (e) {
                return fallback;
            }
        };

        const safeLoadConfig = () => {
            if (typeof window === 'undefined') return DEFAULT_CONFIG;
            try {
                const raw = localStorage.getItem(STORAGE_KEY_CONFIG);
                const parsed = raw ? JSON.parse(raw) : {};
                const mergedHabits = Array.isArray(parsed.habits) ? parsed.habits : DEFAULT_HABITS;
                return { ...DEFAULT_CONFIG, ...parsed, habits: mergedHabits };
            } catch (e) {
                return DEFAULT_CONFIG;
            }
        };

        // ============================================================================
        // 3. ËºîÂä©ÂáΩÊï∏ (Helpers)
        // ============================================================================

        const copyToClipboard = async (text) => {
            if (!text) return false;
            try { await navigator.clipboard.writeText(text); return true; } catch (err) { return false; }
        };

        const extractInsight = (content) => {
            if (!content) return { type: 'empty', text: 'ÁÑ°ÊñáÂ≠óÁ¥ÄÈåÑ' };
            const foundBias = BIAS_KEYWORDS.find(k => content.includes(k));
            if (foundBias) {
                const sentences = content.split(/[„ÄÇ\n]/);
                const targetSentence = sentences.find(s => s.includes(foundBias)) || foundBias;
                return { type: 'bias', text: targetSentence.trim().slice(0, 60), label: 'Bias' };
            }
            const driftMatch = content.match(/(?:Drift Point|ÂÅèÁßªÈªû|Drift)[^:\n]*[:Ôºö]?\s*(.*)/i);
            if (driftMatch && driftMatch[1] && driftMatch[1].trim() !== 'None') {
                return { type: 'drift', text: driftMatch[1].replace(/\*\*/g, '').trim(), label: 'Drift' };
            }
            const lines = content.split('\n');
            let previewText = '';
            for (let line of lines) {
                const trimmed = line.trim();
                if (!trimmed || trimmed.startsWith('#') || trimmed.includes('Daily Metrics') || trimmed.includes('Mood:') || trimmed.includes('Day Summary')) {
                    continue;
                }
                const cleanLine = trimmed.replace(/[>*\-]/g, '').trim();
                if (cleanLine.length > 5) { 
                    previewText = cleanLine;
                    break; 
                }
            }
            const finalText = previewText || 'ÁÑ°Ë©≥Á¥∞ÂÖßÂÆπ';
            return { type: 'general', text: finalText.slice(0, 80) + (finalText.length > 80 ? '...' : ''), label: 'Log' };
        };

        const getIconComponent = (iconName) => {
            const map = { BookOpen, Activity, Zap, Brain, Star, Anchor, TrendingUp, Target, Heart, Rocket, Terminal };
            const Icon = map[iconName] || Star;
            return Icon; 
        };

        const parseGraphSeeds = (note) => {
            if (!note || typeof note !== 'string') return { tags: [], links: [] };
            const tags = (note.match(/#([\w\u4e00-\u9fa5]+)/g) || []).map(t => t.slice(1)).filter(t => !BIAS_KEYWORDS.includes(t));
            const links = (note.match(/\[\[(\d{4}-\d{2}-\d{2})\]\]/g) || []).map(l => l.slice(2, -2));
            return { tags, links };
        };

        // ============================================================================
        // 4. Áâ©ÁêÜÂºïÊìé (Physics Engine)
        // ============================================================================

        const simulateGraph = (nodes, links, width, height, mode = 'gravity') => {
            const iterations = 100;
            let repulsion = 300;
            let attraction = 0.03;
            let centerPull = 0.04;
            
            if (mode === 'cluster') {
                repulsion = 150; attraction = 0.08; centerPull = 0.05;
            } else if (mode === 'graph') {
                repulsion = 400; attraction = 0.02; centerPull = 0.02;
            }

            const groups = {};
            if (mode === 'cluster') {
                nodes.forEach(n => {
                    const habitKey = Object.keys(n.data.habits || {}).find(k => n.data.habits[k]) || 'uncategorized';
                    if (!groups[habitKey]) groups[habitKey] = [];
                    groups[habitKey].push(n);
                });
            }

            nodes.forEach((n, idx) => {
                if (!n.x) {
                    n.x = width / 2 + (Math.random() - 0.5) * 100;
                    n.y = height / 2 + (Math.random() - 0.5) * 100;
                }
                n.vx = 0; n.vy = 0;
            });

            for (let i = 0; i < iterations; i++) {
                for (let j = 0; j < nodes.length; j++) {
                    for (let k = j + 1; k < nodes.length; k++) {
                        const n1 = nodes[j]; const n2 = nodes[k];
                        const dx = n1.x - n2.x; const dy = n1.y - n2.y;
                        const distSq = dx*dx + dy*dy || 1;
                        const force = repulsion / Math.sqrt(distSq);
                        const fx = (dx / Math.sqrt(distSq)) * force;
                        const fy = (dy / Math.sqrt(distSq)) * force;
                        n1.vx += fx; n1.vy += fy;
                        n2.vx -= fx; n2.vy -= fy;
                    }
                }

                links.forEach(link => {
                    const n1 = nodes.find(n => n.id === link.source);
                    const n2 = nodes.find(n => n.id === link.targetRaw);
                    if (n1 && n2) {
                        const dx = n2.x - n1.x; const dy = n2.y - n1.y;
                        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                        const force = dist * attraction;
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        n1.vx += fx; n1.vy += fy;
                        n2.vx -= fx; n2.vy -= fy;
                    }
                });

                if (mode === 'cluster') {
                    const groupKeys = Object.keys(groups);
                    const angleStep = (2 * Math.PI) / groupKeys.length;
                    const radius = 300;
                    groupKeys.forEach((key, gIdx) => {
                        const cx = width/2 + Math.cos(gIdx * angleStep) * radius;
                        const cy = height/2 + Math.sin(gIdx * angleStep) * radius;
                        groups[key].forEach(n => {
                            n.vx += (cx - n.x) * 0.05;
                            n.vy += (cy - n.y) * 0.05;
                        });
                    });
                } else {
                    nodes.forEach(n => {
                        const hasLink = links.some(l => l.source === n.id || l.targetRaw === n.id);
                        const pull = hasLink ? centerPull : centerPull * 0.5;
                        n.vx += (width / 2 - n.x) * pull;
                        n.vy += (height / 2 - n.y) * pull;
                    });
                }

                nodes.forEach(n => {
                    n.vx *= 0.9; n.vy *= 0.9;
                    n.x += n.vx; n.y += n.vy;
                });
            }
            return nodes;
        };

        // ============================================================================
        // 5. ÂÖÉ‰ª∂ (Components)
        // ============================================================================

        const NeuralGraph = memo(({ logs, onNodeClick }) => {
            const [transform, setTransform] = useState({ x: 0, y: 0, k: 1 });
            const [mode, setMode] = useState('gravity'); 
            const [hoveredNode, setHoveredNode] = useState(null);
            const touchRef = useRef({ dist: 0, isDragging: false, lastX: 0, lastY: 0, startScale: 1 });

            const { nodes, links } = useMemo(() => {
                if (!logs || logs.length === 0) return { nodes: [], links: [] };
                const _nodes = []; const _links = []; const tagMap = new Map();

                logs.forEach(entry => {
                    const tags = (entry.graphSeeds?.tags || '').split(' ').filter(t => t.length > 1);
                    const explicitLinks = (entry.graphSeeds?.links || '').match(/\[\[(.*?)\]\]/g) || [];
                    const noteTags = (entry.note.match(/#([\w\u4e00-\u9fa5]+)/g) || []).map(t => t.slice(1));
                    const allTags = [...new Set([...tags.map(t=>t.replace('#','')), ...noteTags])];

                    // Parse Graph Field for implicit links/keywords
                    const graphFieldContent = entry.graphSeeds?.graph || '';
                    if (graphFieldContent) {
                        const customLinks = graphFieldContent.match(/\[\[(.*?)\]\]/g) || [];
                        customLinks.forEach(l => explicitLinks.push(l));
                    }

                    const mood = entry.metrics?.mood || 5;
                    const focus = entry.metrics?.focus || 5;

                    const node = { 
                        id: entry.date, 
                        size: 10 + (focus * 2.5), 
                        color: mood > 7 ? '#10b981' : mood < 4 ? '#e11d48' : '#6366f1', 
                        data: entry,
                        tags: allTags
                    };
                    _nodes.push(node);

                    allTags.forEach(tag => {
                        if (!tagMap.has(tag)) tagMap.set(tag, []);
                        tagMap.get(tag).push(entry.date);
                    });
                    explicitLinks.forEach(l => {
                        const targetDate = l.slice(2, -2);
                        _links.push({ source: entry.date, targetRaw: targetDate, type: 'manual' });
                    });
                });

                tagMap.forEach((dates, tag) => {
                    dates.sort();
                    for (let i = 0; i < dates.length - 1; i++) {
                        _links.push({ source: dates[i], targetRaw: dates[i+1], type: 'tag', tag: tag });
                    }
                });

                const validLinks = _links.filter(l => _nodes.find(n => n.id === l.source) && _nodes.find(n => n.id === l.targetRaw));
                const simulatedNodes = simulateGraph(_nodes, validLinks, 1000, 800, mode);
                const simulatedLinks = validLinks.map(l => {
                    const s = simulatedNodes.find(n => n.id === l.source);
                    const t = simulatedNodes.find(n => n.id === l.targetRaw);
                    return { x1: s.x, y1: s.y, x2: t.x, y2: t.y, type: l.type, tag: l.tag };
                });

                return { nodes: simulatedNodes, links: simulatedLinks };
            }, [logs, mode]); 

            const handleWheel = useCallback((e) => {
                e.preventDefault(); 
                const nk = Math.max(0.2, Math.min(4, e.deltaY < 0 ? transform.k * 1.1 : transform.k / 1.1)); 
                setTransform(t=>({...t, k:nk}));
            }, [transform.k]);

            const handleMouseDown = useCallback((e) => {
                touchRef.current.isDragging = true;
                touchRef.current.lastX = e.clientX;
                touchRef.current.lastY = e.clientY;
            }, []);

            const handleMouseMove = useCallback((e) => {
                if (!touchRef.current.isDragging) return;
                const dx = e.clientX - touchRef.current.lastX;
                const dy = e.clientY - touchRef.current.lastY;
                setTransform(t => ({ ...t, x: t.x + dx, y: t.y + dy }));
                touchRef.current.lastX = e.clientX;
                touchRef.current.lastY = e.clientY;
            }, []);

            const handleMouseUp = () => { touchRef.current.isDragging = false; };

            const handleTouchStart = (e) => {
                if (e.touches.length === 1) {
                    touchRef.current.isDragging = true;
                    touchRef.current.lastX = e.touches[0].clientX;
                    touchRef.current.lastY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    touchRef.current.isDragging = false;
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    touchRef.current.dist = dist;
                    touchRef.current.startScale = transform.k;
                }
            };

            const handleTouchMove = (e) => {
                e.preventDefault(); 
                if (e.touches.length === 1 && touchRef.current.isDragging) {
                    const dx = e.touches[0].clientX - touchRef.current.lastX;
                    const dy = e.touches[0].clientY - touchRef.current.lastY;
                    setTransform(t => ({ ...t, x: t.x + dx, y: t.y + dy }));
                    touchRef.current.lastX = e.touches[0].clientX;
                    touchRef.current.lastY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    const dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
                    if (touchRef.current.dist > 0) {
                        const delta = dist / touchRef.current.dist;
                        setTransform(t => ({ ...t, k: Math.max(0.2, Math.min(4, touchRef.current.startScale * delta)) }));
                    }
                }
            };

            const isConnected = useCallback((nodeId) => {
                if (!hoveredNode) return false;
                if (nodeId === hoveredNode.id) return true;
                return links.some(l => (l.source === hoveredNode.id && l.targetRaw === nodeId) || (l.targetRaw === hoveredNode.id && l.source === nodeId));
            }, [hoveredNode, links]);

            return (
                <div className="w-full h-[500px] bg-slate-900 rounded-3xl overflow-hidden relative border border-slate-800 shadow-2xl cursor-move group select-none"
                     onWheel={handleWheel} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp}
                     onMouseLeave={() => { handleMouseUp(); setHoveredNode(null); }} onTouchStart={handleTouchStart} onTouchMove={handleTouchMove} onTouchEnd={handleMouseUp}>
                    
                    <div className="absolute top-4 right-4 z-20 flex gap-2">
                        {[{ id: 'gravity', icon: Layers }, { id: 'cluster', icon: LayoutGrid }, { id: 'graph', icon: GitGraph }].map(m => (
                            <button key={m.id} onClick={(e) => { e.stopPropagation(); setMode(m.id); }} 
                                className={`p-2 rounded-lg backdrop-blur-md border transition-all ${mode === m.id ? 'bg-indigo-600 border-indigo-400 text-white' : 'bg-slate-800/80 border-slate-700 text-slate-400'}`}>
                                <m.icon size={16} />
                            </button>
                        ))}
                    </div>

                    <div className="absolute top-4 left-4 pointer-events-none z-10 flex flex-col gap-2">
                        <div className="bg-slate-800/90 backdrop-blur p-3 rounded-xl border border-slate-700 text-xs text-slate-300 font-mono shadow-lg">
                            <div className="font-bold text-white mb-1 flex items-center gap-2"><Brain className="w-3 h-3 text-indigo-400"/> Neural Map</div>
                            <div className="opacity-70">Mode: {mode.toUpperCase()}</div>
                        </div>
                    </div>
                    
                    <svg width="0" height="0">
                        <defs>
                            <filter id="glow" x="-50%" y="-50%" width="200%" height="200%">
                                <feGaussianBlur stdDeviation="3" result="coloredBlur" />
                                <feMerge><feMergeNode in="coloredBlur" /><feMergeNode in="SourceGraphic" /></feMerge>
                            </filter>
                        </defs>
                    </svg>

                    <svg className="w-full h-full pointer-events-none">
                        <g transform={`translate(${transform.x},${transform.y}) scale(${transform.k})`}>
                            {links.map((l, i) => {
                                const isRelated = hoveredNode && (l.source === hoveredNode.id || l.targetRaw === hoveredNode.id);
                                return <line key={i} x1={l.x1} y1={l.y1} x2={l.x2} y2={l.y2} 
                                    stroke={l.type==='manual' ? '#a5b4fc' : (l.type==='tag' ? '#64748b' : '#475569')} 
                                    strokeWidth={isRelated ? 3 : (l.type==='manual'?2:1)} 
                                    opacity={hoveredNode ? (isRelated ? 1 : 0.1) : (l.type==='manual'?0.8:0.3)} 
                                    strokeDasharray={l.type==='tag' && !isRelated ? "3,3" : "0"}/>;
                            })}
                            {nodes.map(n => {
                                const isDimmed = hoveredNode && !isConnected(n.id);
                                const isHighlight = n.data.metrics.focus > 7 || n.data.metrics.mood > 8;
                                return (
                                    <g key={n.id} transform={`translate(${n.x},${n.y})`} 
                                       className="pointer-events-auto cursor-pointer transition-opacity duration-300" 
                                       style={{opacity: isDimmed ? 0.1 : 1}} 
                                       onClick={(e) => { e.stopPropagation(); onNodeClick(n); }}>
                                        {isHighlight && <circle r={n.size + 6} fill={n.color} opacity={0.3} style={{filter: 'blur(3px)'}} />}
                                        <circle r={n.size} fill={n.color} stroke="#0f172a" strokeWidth={2} onMouseEnter={() => setHoveredNode(n)} />
                                        {(transform.k > 1.2 || (hoveredNode && isConnected(n.id)) || isHighlight) && (
                                            <text y={n.size + 14} textAnchor="middle" fill="white" fontSize={10} fontWeight="bold" className="drop-shadow-md" style={{textShadow:'0 2px 4px rgba(0,0,0,0.8)'}}>{n.id}</text>
                                        )}
                                    </g>
                                );
                            })}
                        </g>
                    </svg>
                </div>
            );
        });

        // ... [MarkdownRenderer, ContextModal, ConfirmModal]
        const MarkdownRenderer = memo(({ content }) => {
            if (!content) return <div className="text-slate-300 italic text-sm text-center py-10">Â∞öÁÑ°ÂÖßÂÆπ</div>;
            return (
                <div className="space-y-3 text-slate-700 text-sm font-mono leading-relaxed">
                    {content.split('\n').map((line, i) => {
                        if (line.startsWith('# ')) return <h3 key={i} className="text-lg font-bold text-indigo-700 mt-4 border-b border-indigo-100 pb-1">{line.replace('# ', '')}</h3>;
                        if (line.startsWith('## ')) return <h4 key={i} className="text-base font-bold text-slate-800 mt-3 flex items-center gap-2"><div className="w-1 h-4 bg-indigo-500 rounded-full"/>{line.replace('## ', '')}</h4>;
                        if (line.startsWith('> ')) return <div key={i} className="border-l-4 border-indigo-200 pl-3 py-2 my-2 bg-slate-50 text-slate-600 italic rounded-r-lg">{line.replace('> ', '')}</div>;
                        return <p key={i} className="min-h-[1em]">{line}</p>;
                    })}
                </div>
            );
        });

        const ContextModal = ({ mainNode, logs, onClose, onOpenEntry }) => {
            const connections = useMemo(() => {
                if (!mainNode) return [];
                const mainTags = mainNode.tags || [];
                const mainId = mainNode.id;
                const mainLog = logs.find(l => l.date === mainId);
                if (mainLog) mainLog.connectionReason = 'Current Focus';
                const related = logs.filter(l => {
                    if (l.date === mainId) return false;
                    const logSeeds = parseGraphSeeds(l.note);
                    const logTags = logSeeds.tags;
                    const sharedTags = logTags.filter(t => mainTags.includes(t));
                    const logLinks = logSeeds.links;
                    const mainLinks = parseGraphSeeds(mainNode.data.note).links;
                    const isLinked = logLinks.includes(mainId) || mainLinks.includes(l.date);
                    if (sharedTags.length > 0 || isLinked) {
                        l.connectionReason = isLinked ? 'Direct Link' : `#${sharedTags[0]}`;
                        return true;
                    }
                    return false;
                }).slice(0, 10); 
                return mainLog ? [mainLog, ...related] : related;
            }, [mainNode, logs]);

            if (!mainNode) return null;
            return (
                <div className="fixed inset-0 z-[60] flex items-center justify-center p-4 bg-slate-900/80 backdrop-blur-sm animate-fade-in" onClick={onClose}>
                    <div className="w-full max-w-2xl max-h-[85vh] overflow-y-auto custom-scrollbar bg-transparent flex flex-col gap-4 animate-scale-in" onClick={e => e.stopPropagation()}>
                        <div className="flex items-center gap-2 text-white/80 pb-2 border-b border-white/10">
                            <Network className="w-5 h-5"/>
                            <span className="font-bold text-lg tracking-tight">Context Cluster: {mainNode.id}</span>
                        </div>
                        {connections.length > 0 ? (
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                                {connections.map((conn, idx) => (
                                    <div key={conn.date} onClick={() => onOpenEntry(conn)} 
                                        className={`rounded-xl p-4 cursor-pointer hover:scale-[1.01] transition-all shadow-lg border-l-4 group relative overflow-hidden ${idx === 0 ? 'bg-indigo-50 border-indigo-500 ring-2 ring-indigo-200' : 'bg-white/95 backdrop-blur hover:bg-white border-slate-300'}`}>
                                        <div className="flex justify-between items-center mb-1">
                                            <span className="font-bold text-slate-800 text-sm flex items-center gap-2">{conn.date} {idx === 0 && <MapPin size={12} className="text-indigo-600"/>}</span>
                                            <span className={`text-[10px] font-bold px-2 py-0.5 rounded-full border ${idx === 0 ? 'bg-indigo-100 text-indigo-700 border-indigo-200' : 'bg-slate-100 text-slate-600 border-slate-200'}`}>{conn.connectionReason}</span>
                                        </div>
                                        <p className="text-xs text-slate-500 line-clamp-2">{extractInsight(conn.note).text}</p>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="text-white/50 text-center py-10 italic">No direct connections found.</div>
                        )}
                    </div>
                </div>
            );
        };

        const ConfirmModal = ({ isOpen, title, message, onConfirm, onCancel }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-[150] flex items-center justify-center p-4 animate-fade-in">
                    <div className="absolute inset-0 bg-slate-900/40 backdrop-blur-sm transition-all" onClick={onCancel} />
                    <div className="bg-white/95 w-full max-w-xs rounded-3xl shadow-2xl p-6 relative z-10 animate-scale-in text-center border border-white/20 backdrop-blur-md">
                        <div className="w-12 h-12 bg-red-50 rounded-full flex items-center justify-center mx-auto mb-4"><AlertCircle className="w-6 h-6 text-red-500" /></div>
                        <h3 className="text-lg font-bold text-slate-800 mb-2">{title}</h3>
                        <p className="text-sm text-slate-500 mb-6 leading-relaxed">{message}</p>
                        <div className="flex gap-3">
                        <button onClick={onCancel} className="flex-1 py-3 bg-slate-100 text-slate-600 rounded-2xl font-bold text-sm hover:bg-slate-200">ÂèñÊ∂à</button>
                        <button onClick={onConfirm} className="flex-1 py-3 bg-red-500 text-white rounded-2xl font-bold text-sm hover:bg-red-600 shadow-lg">Á¢∫ÂÆö</button>
                        </div>
                    </div>
                </div>
            );
        };

        // ============================================================================
        // 6. ‰∏ªÁ®ãÂºè (Main App)
        // ============================================================================

        const LifeOS = () => {
            const [activeTab, setActiveTab] = useState('input');
            const [isMenuOpen, setIsMenuOpen] = useState(false); 
            const [notification, setNotification] = useState(null);
            const [selectedEntry, setSelectedEntry] = useState(null); 
            const [contextNode, setContextNode] = useState(null); 
            const [confirmState, setConfirmState] = useState({ isOpen: false, title: '', message: '', action: null });
            const [isSyncing, setIsSyncing] = useState(false); // [New] Sync State
            
            // Data
            const [logs, setLogs] = useState(() => sanitizeData(safeLoad(STORAGE_KEY_LOGS, [])));
            const [config, setConfig] = useState(() => safeLoadConfig());
            // Ensure settings has github structure
            const [userSettings, setUserSettings] = useState(() => {
                const loaded = safeLoad(STORAGE_KEY_SETTINGS, DEFAULT_SETTINGS);
                return { ...DEFAULT_SETTINGS, ...loaded, github: { ...DEFAULT_SETTINGS.github, ...(loaded.github || {}) } };
            });
            const [prompts, setPrompts] = useState(() => safeLoad(STORAGE_KEY_PROMPTS, DEFAULT_PROMPTS)); 
            const [ccaData, setCcaData] = useState(() => safeLoad(STORAGE_KEY_CCA, {}));

            // Input State
            const [entry, setEntry] = useState({ date: new Date().toISOString().split('T')[0], ...DEFAULT_ENTRY });
            const [newHabitName, setNewHabitName] = useState(''); 
            const [dashboardMonth, setDashboardMonth] = useState(new Date().toISOString().slice(0, 7));
            const [isEditingReview, setIsEditingReview] = useState(false);

            useEffect(() => {
                if (!entry.date) setEntry(prev => ({ ...prev, date: new Date().toISOString().split('T')[0] }));
                console.log(`[LifeOS] System Mounted v${VERSION}`);
                
                // Auto-sync if token exists
                if (userSettings.github?.token) {
                    syncFromGitHub();
                }
            }, []);

            useEffect(() => { try { localStorage.setItem(STORAGE_KEY_LOGS, JSON.stringify(logs)); } catch (e) { showToast("‚ùå ÂÑ≤Â≠òÂ§±Êïó", "error"); } }, [logs]);
            useEffect(() => { localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(config)); }, [config]);
            useEffect(() => { localStorage.setItem(STORAGE_KEY_SETTINGS, JSON.stringify(userSettings)); }, [userSettings]); // Save settings
            useEffect(() => { localStorage.setItem(STORAGE_KEY_PROMPTS, JSON.stringify(prompts)); }, [prompts]);
            useEffect(() => { localStorage.setItem(STORAGE_KEY_CCA, JSON.stringify(ccaData)); }, [ccaData]);

            const showToast = (msg, type='success') => { setNotification({msg, type}); setTimeout(() => setNotification(null), 3000); };

            // [New] Cloud Sync Logic
            const syncFromGitHub = async () => {
                if (!userSettings.github?.token || !userSettings.github?.owner || !userSettings.github?.repo) {
                    showToast("‚ö†Ô∏è Ë´ãÂÖàË®≠ÂÆö GitHub Ë≥áË®ä", "warning");
                    return;
                }
                
                setIsSyncing(true);
                showToast("‚òÅÔ∏è ÈñãÂßãÂêåÊ≠•...", "info");

                try {
                    const { owner, repo, token } = userSettings.github;
                    const headers = { 'Authorization': `token ${token}` };

                    // Helper to fetch files from a folder
                    const fetchFolder = async (path) => {
                        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, { headers });
                        if (!res.ok) return [];
                        const files = await res.json();
                        if (!Array.isArray(files)) return [];
                        return files.filter(f => f.name.endsWith('.json'));
                    };

                    // [Step 3 Implemented] Fetch from both Inbox and Archive
                    const [inboxFiles, archiveFiles] = await Promise.all([
                        fetchFolder('data/inbox'),
                        fetchFolder('data/archive') 
                    ]);

                    const allFiles = [...inboxFiles, ...archiveFiles];

                    if (allFiles.length === 0) {
                         showToast("‚òÅÔ∏è Èõ≤Á´ØÁÑ°Êñ∞Ë≥áÊñô");
                         // If we found nothing new, we don't throw error, just finish.
                         // But if fetch failed, fetchFolder returns [], so we might silently fail. 
                         // For simplicity in this lightweight app, this is acceptable.
                    } else {
                        const cloudLogs = await Promise.all(allFiles.map(async (file) => {
                            const contentRes = await fetch(file.download_url);
                            const data = await contentRes.json();
                            // Transform backend JSON to frontend Log format
                            const date = data.analysis?.date || data.date || "1970-01-01";
                            return sanitizeLogEntry({
                                date: date,
                                note: data.raw_text || data.note || "",
                                metrics: { 
                                    mood: data.analysis?.mood || 5,
                                    focus: data.analysis?.focus || 5,
                                    energy: data.analysis?.energy || 5,
                                    deepWork: 0
                                },
                                graphSeeds: {
                                    tags: (data.analysis?.tags || []).join(' '),
                                    links: '', // Populate if available
                                    graph: ''
                                }
                            });
                        }));
                        
                        // Merge with local logs
                        setLogs(prev => {
                            const combined = [...prev];
                            cloudLogs.forEach(cloudLog => {
                                const idx = combined.findIndex(l => l.date === cloudLog.date);
                                if (idx >= 0) combined[idx] = cloudLog;
                                else combined.push(cloudLog);
                            });
                            return combined.sort((a,b) => new Date(a.date) - new Date(b.date));
                        });
                        showToast(`‚úÖ ÂêåÊ≠•ÂÆåÊàê (ÂÖ± ${cloudLogs.length} Á≠Ü)`);
                    }
                } catch (e) {
                    console.error("Cloud fetch failed", e);
                    showToast(`‚ùå ÂêåÊ≠•Â§±Êïó: ${e.message}`, "error");
                } finally {
                    setIsSyncing(false);
                }
            };

            // [Updated] Save Entry with GitHub Dispatch
            const handleSaveEntry = async () => {
                const finalSeeds = { 
                    tags: entry.graphSeeds?.tags || '', 
                    links: entry.graphSeeds?.links || '',
                    graph: entry.graphSeeds?.graph || '' 
                };
                let finalNote = entry.note;
                if (!finalNote) {
                    finalNote = `# [${entry.date}] Log\n> Mood: ${entry.mood} | Focus: ${entry.focus}\n\n## Summary\n${entry.graphSeeds?.tags ? `Tags: ${entry.graphSeeds.tags}` : ''}`;
                }
                
                if (finalSeeds.graph && !finalNote.includes('## Graph') && !finalNote.includes('Graph:')) {
                    finalNote += `\n\n## Graph\n${finalSeeds.graph}`;
                }

                if ((entry.habits['creation'] || entry.habits['native_coding']) && entry.readingTime < 15 && !finalNote.includes('Core Weakness')) {
                    finalNote += "\n\n‚ö†Ô∏è [Warning: Core Weakness]";
                    showToast("‚ö†Ô∏è ÂÅµÊ∏¨Âà∞Ê†∏ÂøÉËÉΩÂäõËôõÂº±", "warning");
                }

                // 1. Optimistic Update (Local)
                const newLog = sanitizeLogEntry({
                    ...entry,
                    metrics: { mood: entry.mood, focus: entry.focus, energy: entry.energy, deepWork: entry.readingTime },
                    graphSeeds: finalSeeds,
                    note: finalNote,
                    timestamp: Date.now()
                });

                setLogs(prev => {
                    const filtered = prev.filter(l => l.date !== newLog.date);
                    return [...filtered, newLog].sort((a,b) => new Date(a.date) - new Date(b.date));
                });
                setEntry(prev => ({ ...DEFAULT_ENTRY, date: prev.date })); 

                // 2. Dispatch to GitHub (If configured)
                if (userSettings.github?.token && userSettings.github?.owner && userSettings.github?.repo) {
                    try {
                        showToast("üöÄ ÁôºÈÄÅËá≥Á•ûÁ∂ìÈõ≤Á´Ø...", "info");
                        // [Step 2] Construct payload for GitHub Action
                        const payload = {
                            event_type: "new_journal_entry",
                            client_payload: {
                                text: finalNote,
                                metadata: {
                                    date: newLog.date,
                                    mood: newLog.metrics.mood,
                                    tags: finalSeeds.tags
                                }
                            }
                        };

                        const response = await fetch(`https://api.github.com/repos/${userSettings.github.owner}/${userSettings.github.repo}/dispatches`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `token ${userSettings.github.token}`,
                                'Accept': 'application/vnd.github.v3+json'
                            },
                            body: JSON.stringify(payload)
                        });

                        if (response.ok) {
                            showToast("‚úÖ Èõ≤Á´ØÊåá‰ª§Â∑≤Ëß∏Áôº (Action Dispatched)");
                        } else {
                            throw new Error(`GitHub API: ${response.status}`);
                        }
                    } catch (error) {
                        console.error(error);
                        showToast(`‚ùå Èõ≤Á´ØÂÇô‰ªΩÂ§±Êïó (ÂÉÖÊú¨Âú∞ÂÑ≤Â≠ò): ${error.message}`, "error");
                    }
                } else {
                    showToast("‚ö†Ô∏è Êú™Ë®≠ÂÆö GitHubÔºåÂÉÖÊú¨Âú∞ÂÑ≤Â≠ò", "warning");
                }
            };

            const handleAIParse = () => {
                const text = entry.note;
                if (!text) return;
                
                const mood = text.match(/(?:Mood|ÂøÉÊÉÖ)[\s\S]*?(\d+(?:\.\d+)?)/i);
                const focus = text.match(/(?:Focus|Â∞àÊ≥®)[\s\S]*?(\d+(?:\.\d+)?)/i);
                const energy = text.match(/(?:Energy|ËÉΩÈáè)[\s\S]*?(\d+(?:\.\d+)?)/i);
                const deep = text.match(/(?:Deep|Reading|Ê∑±Â∫¶)[\s\S]*?(\d+(?:\.\d+)?)/i);
                const dateMatch = text.match(/(?:Date|Êó•Êúü|^#\s*\[?)?\s*(\d{4}-\d{2}-\d{2})/m);
                const targetDate = dateMatch ? dateMatch[1] : entry.date;
                const tags = (text.match(/#([\w\u4e00-\u9fa5]+)/g) || []).join(' ');
                const links = (text.match(/\[\[(.*?)\]\]/g) || []).join(' ');

                const graphBlockMatch = text.match(/(?:##\s*Graph|Graph:)[\s\S]*?(?=\n#|$)/i);
                let graphContent = '';
                if (graphBlockMatch) {
                    graphContent = graphBlockMatch[0].replace(/^(?:##\s*Graph|Graph:)[\s\r\n]*/i, '').trim();
                }

                let detectedHabits = { ...entry.habits };
                config.habits.forEach(h => {
                    if (text.toLowerCase().includes(h.id) || text.includes(h.label.split(' ')[0])) {
                        detectedHabits[h.id] = true;
                    }
                });
                
                setEntry(prev => ({
                    ...prev,
                    date: targetDate,
                    mood: mood ? parseInt(mood[1]) : prev.mood,
                    focus: focus ? parseInt(focus[1]) : prev.focus,
                    energy: energy ? parseInt(energy[1]) : prev.energy,
                    readingTime: deep ? parseInt(deep[1]) : prev.readingTime,
                    habits: detectedHabits,
                    graphSeeds: { 
                        tags: tags, 
                        links: links,
                        graph: graphContent 
                    }
                }));
                showToast("ü™Ñ AI ÊäìÂèñÂÆåÊàê (Âê´ Graph ÂçÄÂ°ä)");
            };

            // ... [Delete, Clear, Habit, CCA, Upgrade handlers]
            const requestDelete = (date) => setConfirmState({ isOpen: true, title: 'Âà™Èô§Á¥ÄÈåÑ', message: `Á¢∫ÂÆöË¶ÅÂà™Èô§ ${date} ÁöÑÁ¥ÄÈåÑÂóéÔºü`, action: () => { setLogs(prev => prev.filter(d => d.date !== date)); setSelectedEntry(null); setConfirmState({ isOpen: false }); showToast("üóëÔ∏è Á¥ÄÈåÑÂ∑≤Âà™Èô§"); }});
            const requestClear = () => setConfirmState({ isOpen: true, title: 'Ê∏ÖÁ©∫Ë≥áÊñô', message: 'Á¢∫ÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâË≥áÊñôÂóéÔºü', action: () => { setLogs([]); localStorage.removeItem(STORAGE_KEY_LOGS); setConfirmState({ isOpen: false }); showToast("üßπ Â∑≤Ê∏ÖÁ©∫"); }});
            const addNewHabit = () => { if (!newHabitName.trim()) return; const newHabit = { id: `custom_${Date.now()}`, label: newHabitName, icon: 'Star', active: true }; setConfig({ ...config, habits: [...config.habits, newHabit] }); setNewHabitName(''); };
            const toggleHabit = (id) => { const newHabits = config.habits.map(h => h.id === id ? { ...h, active: !h.active } : h); setConfig({ ...config, habits: newHabits }); };
            const handleUpdateCCA = (month, field, value) => { setCcaData(prev => ({ ...prev, [month]: { ...prev[month], [field]: value } })); };
            const executeSystemUpgrade = (month) => { const reviewText = ccaData[month]?.review; if (!reviewText) { showToast("‚ùå ÁÑ°ÂÖßÂÆπ", "error"); return; } const regex = /\[ADD\]\s*habit:(.*)/g; let match, addedCount = 0; const newHabits = [...config.habits]; while ((match = regex.exec(reviewText)) !== null) { const habitName = match[1].trim(); if (!newHabits.some(h => h.label === habitName) && habitName !== 'NA') { newHabits.push({ id: `evo_${Date.now()}_${addedCount}`, label: habitName, icon: 'Rocket', active: true }); addedCount++; } } if (addedCount > 0) { setConfig({ ...config, habits: newHabits }); showToast(`üöÄ Á≥ªÁµ±ÂçáÁ¥ö: +${addedCount} ÁøíÊÖ£`); } else showToast("‚ö†Ô∏è ÁÑ°Êñ∞Êåá‰ª§", "warning"); };
            const handleChartClick = useCallback((data) => { if (data && data.activePayload && data.activePayload.length > 0) { const payload = data.activePayload[0].payload; setSelectedEntry(payload); } }, []);
            const handleExport = () => { const bundle = { version: VERSION, logs: logs, config: config, settings: userSettings, prompts: prompts, cca: ccaData }; const blob = new Blob([JSON.stringify(bundle, null, 2)], { type: "application/json" }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = `life_os_backup_${new Date().toISOString().split('T')[0]}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); };
            const handleImport = (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (ev) => { try { const json = JSON.parse(ev.target.result); if(json.logs) setLogs(sanitizeData(json.logs)); if(json.config) { const existingIds = new Set(config.habits.map(h => h.id)); const newHabits = json.config.habits.filter(h => !existingIds.has(h.id)); setConfig({ ...json.config, habits: [...config.habits, ...newHabits] }); } if(json.prompts) setPrompts(json.prompts); if(json.cca) setCcaData(json.cca); showToast("‚úÖ ÈÇÑÂéüÊàêÂäü"); } catch(err) { showToast("‚ùå Ê†ºÂºèÈåØË™§", "error"); } }; reader.readAsText(file); };

            // --- Views ---

            const renderInputTab = () => (
                <div className="space-y-6 pb-24 animate-fade-in">
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-200">
                        <div className="flex justify-between items-center mb-4">
                            <span className="text-sm font-bold text-slate-600 flex items-center gap-2"><Edit3 className="w-4 h-4"/> DAILY LOG</span>
                            <input type="date" value={entry.date} onChange={e => setEntry({...entry, date: e.target.value})} className="bg-slate-50 border border-slate-200 rounded-lg px-3 py-1 text-sm font-mono outline-none"/>
                        </div>
                        <textarea 
                            value={entry.note} onChange={e => setEntry({...entry, note: e.target.value})}
                            placeholder="# [YYYY-MM-DD] Title\n> Mood: 8 | Focus: 7\n[T:30] (S) Task...\n\n## Graph\nA -> B\n#Idea"
                            className="w-full h-40 p-4 bg-slate-50 border border-slate-200 rounded-xl text-sm font-mono focus:ring-2 focus:ring-indigo-100 outline-none resize-none leading-relaxed"
                        />
                        <div className="mt-4 pt-4 border-t border-slate-100 grid grid-cols-2 gap-3">
                            <div className="bg-indigo-50 p-2 rounded-xl flex items-center gap-2 border border-indigo-100">
                                <Hash className="w-4 h-4 text-indigo-400"/>
                                <input placeholder="Tags" value={entry.graphSeeds?.tags || ''} onChange={e => setEntry({...entry, graphSeeds: {...entry.graphSeeds, tags: e.target.value}})} className="bg-transparent w-full text-xs font-mono outline-none text-indigo-800 placeholder:text-indigo-300"/>
                            </div>
                            <div className="bg-indigo-50 p-2 rounded-xl flex items-center gap-2 border border-indigo-100">
                                <LinkIcon className="w-4 h-4 text-indigo-400"/>
                                <input placeholder="[[Links]]" value={entry.graphSeeds?.links || ''} onChange={e => setEntry({...entry, graphSeeds: {...entry.graphSeeds, links: e.target.value}})} className="bg-transparent w-full text-xs font-mono outline-none text-indigo-800 placeholder:text-indigo-300"/>
                            </div>
                            <div className="col-span-2 bg-indigo-50 p-2 rounded-xl flex items-center gap-2 border border-indigo-100">
                                <GitGraph className="w-4 h-4 text-indigo-400 flex-shrink-0"/>
                                <input placeholder="Graph Data (Parsed from ## Graph)" value={entry.graphSeeds?.graph || ''} onChange={e => setEntry({...entry, graphSeeds: {...entry.graphSeeds, graph: e.target.value}})} className="bg-transparent w-full text-xs font-mono outline-none text-indigo-800 placeholder:text-indigo-300"/>
                            </div>
                        </div>
                        <div className="flex justify-end gap-2 mt-4">
                            <button onClick={handleAIParse} className="px-4 py-2 rounded-xl bg-slate-100 text-slate-600 text-xs font-bold hover:bg-slate-200 transition-colors flex items-center gap-2"><Wand2 className="w-3 h-3"/> AI Parse</button>
                            <button onClick={handleSaveEntry} className="px-6 py-2 rounded-xl bg-indigo-600 text-white text-xs font-bold hover:bg-indigo-700 transition-colors shadow-lg shadow-indigo-200 flex items-center gap-2"><Save className="w-3 h-3"/> Save</button>
                        </div>
                    </div>
                    {/* ... Metrics sliders & Habits (Same as before) ... */}
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-200 space-y-4">
                        {[ {k:'mood', c:'indigo', l:'Mood'}, {k:'focus', c:'rose', l:'Focus'}, {k:'energy', c:'amber', l:'Energy'}, {k:'readingTime', c:'blue', l:'Deep Work', m:240, s:10} ].map(m => (
                            <div key={m.k} className="flex items-center gap-4">
                                <label className="w-20 text-xs font-bold text-slate-400 uppercase">{m.l}</label>
                                <input type="range" min="0" max={m.m||10} step={m.s||1} value={entry[m.k]} onChange={e => setEntry({...entry, [m.k]: parseInt(e.target.value)})} className={`flex-1 h-2 bg-slate-100 rounded-lg appearance-none cursor-pointer accent-${m.c}-500`}/>
                                <span className={`w-8 text-right text-sm font-black text-${m.c}-500`}>{entry[m.k]}</span>
                            </div>
                        ))}
                    </div>
                    <div className="grid grid-cols-2 gap-3">
                        {config.habits.filter(h => h.active).map(habit => {
                            const Icon = getIconComponent(habit.icon); const isActive = entry.habits[habit.id];
                            return (
                            <button key={habit.id} onClick={() => setEntry({...entry, habits: {...entry.habits, [habit.id]: !isActive}})} 
                                className={`p-4 rounded-2xl border transition-all flex items-center justify-between ${isActive ? 'bg-slate-800 border-slate-800 text-white shadow-lg' : 'bg-white border-slate-100 text-slate-400'}`}>
                                <span className="text-xs font-bold">{habit.label}</span><Icon className={`w-5 h-5 ${isActive ? 'opacity-100' : 'opacity-20'}`} />
                            </button>
                            );
                        })}
                    </div>
                </div>
            );

            // [Updated] Settings View with GitHub Config
            const renderSettingsView = () => (
                <div className="space-y-6 pb-24 animate-fade-in">
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                        <h3 className="text-base font-bold text-slate-700 mb-4 flex items-center gap-2"><Github className="w-4 h-4 text-indigo-500"/> GitHub Integration</h3>
                        <div className="space-y-3">
                            <div>
                                <label className="text-xs font-bold text-slate-400 uppercase">Owner</label>
                                <input type="text" placeholder="e.g. your-username" value={userSettings.github?.owner || ''} onChange={(e) => setUserSettings({...userSettings, github: {...userSettings.github, owner: e.target.value}})} className="w-full bg-slate-50 border border-slate-200 rounded-xl p-2 text-sm outline-none" />
                            </div>
                            <div>
                                <label className="text-xs font-bold text-slate-400 uppercase">Repo</label>
                                <input type="text" placeholder="e.g. life-os" value={userSettings.github?.repo || ''} onChange={(e) => setUserSettings({...userSettings, github: {...userSettings.github, repo: e.target.value}})} className="w-full bg-slate-50 border border-slate-200 rounded-xl p-2 text-sm outline-none" />
                            </div>
                            <div>
                                <label className="text-xs font-bold text-slate-400 uppercase">Personal Access Token (PAT)</label>
                                <input type="password" placeholder="ghp_..." value={userSettings.github?.token || ''} onChange={(e) => setUserSettings({...userSettings, github: {...userSettings.github, token: e.target.value}})} className="w-full bg-slate-50 border border-slate-200 rounded-xl p-2 text-sm outline-none" />
                            </div>
                            <button onClick={syncFromGitHub} disabled={isSyncing} className={`w-full py-2 rounded-xl text-xs font-bold flex justify-center items-center gap-2 transition-all ${isSyncing ? 'bg-indigo-50 text-indigo-400' : 'bg-indigo-600 text-white hover:bg-indigo-700'}`}>
                                {isSyncing ? <RefreshCw className="w-3 h-3 animate-spin"/> : <Cloud className="w-3 h-3"/>}
                                {isSyncing ? 'Syncing...' : 'Sync Now'}
                            </button>
                        </div>
                    </div>

                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                        <h3 className="text-base font-bold text-slate-700 mb-2 flex items-center gap-2"><Terminal className="w-4 h-4 text-indigo-500"/> System Prompts</h3>
                        {[ {l:'Monthly',k:'monthly'}, {l:'Daily',k:'daily'} ].map(p => (
                            <div key={p.k} className="mb-4">
                                <div className="flex justify-between items-center mb-1"><label className="text-xs font-bold text-slate-500 uppercase">{p.l}</label><button onClick={() => { copyToClipboard(prompts[p.k]); showToast("üìã Â∑≤Ë§áË£Ω"); }} className="text-[10px] bg-slate-100 px-2 py-1 rounded flex gap-1"><Copy className="w-3 h-3"/> Ë§áË£Ω</button></div>
                                <textarea value={prompts[p.k] || ''} onChange={(e) => setPrompts({...prompts, [p.k]:e.target.value})} className="w-full h-24 bg-slate-50 border border-slate-200 rounded-xl p-3 text-[10px] font-mono resize-none outline-none" />
                            </div>
                        ))}
                    </div>
                    {/* ... Habits and Data sections ... */}
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100">
                        <h3 className="text-base font-bold text-slate-700 mb-2 flex items-center gap-2"><Sliders className="w-4 h-4 text-indigo-500"/> Habits</h3>
                        <div className="flex gap-2 mb-4">
                            <input type="text" placeholder="Êñ∞Â¢ûÁøíÊÖ£..." value={newHabitName} onChange={(e) => setNewHabitName(e.target.value)} className="flex-1 bg-slate-50 border border-slate-200 rounded-lg px-3 py-2 text-sm outline-none" />
                            <button onClick={addNewHabit} className="bg-indigo-600 text-white px-4 rounded-lg text-xs font-bold flex items-center gap-1"><PlusCircle className="w-3 h-3"/> Êñ∞Â¢û</button>
                        </div>
                        <div className="grid grid-cols-1 gap-2">
                            {config.habits.map(h => (
                                <div key={h.id} className="flex items-center justify-between p-3 bg-slate-50 rounded-xl border border-slate-100">
                                    <div className="flex items-center gap-3"><div className={`w-8 h-8 rounded-full flex items-center justify-center ${h.active?'bg-slate-800 text-white':'bg-slate-200 text-slate-400'}`}>{React.createElement(getIconComponent(h.icon), { size: 14 })}</div><span className={`text-sm font-medium ${h.active?'text-slate-700':'text-slate-400 line-through'}`}>{h.label}</span></div>
                                    <button onClick={() => toggleHabit(h.id)} className={`px-3 py-1 rounded-lg text-xs font-bold flex items-center gap-1 ${h.active?'bg-red-50 text-red-500':'bg-emerald-50 text-emerald-600'}`}>{h.active?<><StopCircle className="w-3 h-3"/> ÂÅúÁî®</>:<><PlayCircle className="w-3 h-3"/> ÂïüÁî®</>}</button>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="bg-white p-6 rounded-3xl shadow-sm border border-slate-100 space-y-3">
                        <h3 className="text-base font-bold text-slate-700 mb-2 flex items-center gap-2"><Settings className="w-4 h-4 text-indigo-500"/> Data</h3>
                        <div className="flex gap-2">
                            <button onClick={handleExport} className="flex-1 py-3 bg-indigo-50 text-indigo-600 rounded-xl text-xs font-bold flex justify-center items-center gap-2"><Download className="w-4 h-4"/> Backup</button>
                            <label className="flex-1 py-3 bg-emerald-50 text-emerald-600 rounded-xl text-xs font-bold flex justify-center items-center gap-2 cursor-pointer"><Upload className="w-4 h-4"/> Restore
                                <input type="file" className="hidden" onChange={handleImport}/>
                            </label>
                        </div>
                        <button onClick={requestClear} className="w-full py-3 bg-red-50 text-red-500 rounded-xl text-xs font-bold flex justify-center items-center gap-2"><Trash2 className="w-4 h-4"/> Clear All Data</button>
                    </div>
                </div>
            );

            // [FIX] Re-add Dashboard & History
            const renderDashboard = () => {
                if (!logs || logs.length === 0) return <div className="text-center py-20 text-slate-400">Êï∏ÊìöÁ¥ØÁ©ç‰∏≠...</div>;
                const filteredLogs = logs.filter(l => l.date.startsWith(dashboardMonth));
                const data = filteredLogs.sort((a,b) => new Date(a.date) - new Date(b.date));
                return (
                    <div className="space-y-6 pb-24 animate-fade-in">
                        <div className="flex justify-between items-center bg-white p-3 rounded-2xl shadow-sm border border-slate-100">
                            <div className="flex items-center gap-2 text-slate-700"><Filter className="w-4 h-4 text-indigo-500" /><span className="text-sm font-bold">Month View</span></div>
                            <input type="month" value={dashboardMonth} onChange={(e) => setDashboardMonth(e.target.value)} className="bg-slate-50 border border-slate-200 rounded-lg px-3 py-1.5 text-sm font-mono outline-none focus:ring-2 focus:ring-indigo-100" />
                        </div>
                        <div className="bg-white p-5 rounded-3xl shadow-sm border border-slate-200 h-64">
                            <h3 className="text-sm font-bold text-slate-700 mb-4 flex items-center gap-2"><Activity className="w-4 h-4 text-indigo-500"/> ËøëÊúüË∂®Âã¢ (Recent Trends)</h3>
                            <div style={{ width: '100%', height: '100%', minHeight: '200px' }}>
                                <ResponsiveContainer>
                                    <ComposedChart data={data} onClick={handleChartClick} style={{cursor:'pointer'}}>
                                        <defs><linearGradient id="colorMood" x1="0" y1="0" x2="0" y2="1"><stop offset="5%" stopColor="#6366f1" stopOpacity={0.2}/><stop offset="95%" stopColor="#6366f1" stopOpacity={0}/></linearGradient></defs>
                                        <CartesianGrid strokeDasharray="3 3" vertical={false} stroke="#f1f5f9"/>
                                        <XAxis dataKey="date" tick={{fontSize:10}} tickFormatter={v=>v.slice(8)} axisLine={false} tickLine={false}/>
                                        <YAxis yAxisId="left" orientation="left" stroke="#6366f1" hide domain={[0, 10]}/>
                                        <YAxis yAxisId="right" orientation="right" stroke="#3b82f6" hide/>
                                        <Tooltip contentStyle={{borderRadius:'12px', border:'none'}}/>
                                        <Area yAxisId="left" type="monotone" dataKey="metrics.mood" stroke="#6366f1" fill="url(#colorMood)" strokeWidth={3}/>
                                        <Line yAxisId="left" type="monotone" dataKey="metrics.focus" stroke="#f43f5e" strokeWidth={2} dot={false}/>
                                        <Bar yAxisId="right" dataKey="metrics.deepWork" fill="#93c5fd" opacity={0.3} barSize={20} radius={[4,4,0,0]}/>
                                    </ComposedChart>
                                </ResponsiveContainer>
                            </div>
                        </div>
                        <div className="bg-white p-5 rounded-3xl shadow-sm border border-slate-100">
                            <div className="flex justify-between items-center mb-4"><div className="flex items-center gap-2"><Target className="w-4 h-4 text-emerald-500"/><h3 className="text-sm font-bold text-slate-700">ÊúàÂ∫¶Âæ©Áõ§ (CCA)</h3></div><div className="flex gap-2"><button onClick={() => setIsEditingReview(!isEditingReview)} className="p-1.5 rounded bg-slate-100 hover:bg-slate-200 text-slate-500">{isEditingReview ? <Eye className="w-3 h-3"/> : <Edit3 className="w-3 h-3"/>}</button><button onClick={() => executeSystemUpgrade(dashboardMonth)} className="text-[10px] bg-emerald-50 text-emerald-600 px-3 py-1 rounded-lg hover:bg-emerald-100 font-bold flex items-center gap-1 border border-emerald-200"><Rocket className="w-3 h-3"/> ÂçáÁ¥öÁ≥ªÁµ±</button></div></div>
                            {isEditingReview ? (<textarea value={ccaData[dashboardMonth]?.review || ''} onChange={(e) => handleUpdateCCA(dashboardMonth, 'review', e.target.value)} className="w-full bg-slate-50 border border-slate-200 rounded-xl p-3 text-sm resize-none outline-none h-48 font-mono" placeholder="Ë≤º‰∏äÂ†±Âëä..." />) : (<div className="h-48 overflow-y-auto text-sm text-slate-600 font-mono bg-slate-50 p-3 rounded-xl custom-scrollbar border border-slate-100">{ccaData[dashboardMonth]?.review ? <MarkdownRenderer content={ccaData[dashboardMonth].review} /> : <span className="text-slate-400 italic flex flex-col items-center justify-center h-full gap-2"><FileText className="w-6 h-6 opacity-20"/>Ë´ãË≤º‰∏äÂ†±Âëä...</span>}</div>)}
                        </div>
                    </div>
                );
            };

            const renderHistoryView = () => {
                const historyLogs = [...logs].reverse();
                const getPreviewText = (text) => { if (!text) return 'ÁÑ°Ë©≥Á¥∞ÂÖßÂÆπ'; return extractInsight(text).text; };
                return (
                    <div className="space-y-4 pb-24 animate-fade-in">
                        <div className="flex justify-between items-center mb-4"><h3 className="text-base font-bold text-slate-700 px-1">ËøëÊúüË∂≥Ë∑° ({historyLogs.length})</h3></div>
                        {historyLogs.map((log) => {
                            const insight = extractInsight(log.note);
                            const isDrift = insight.type === 'drift';
                            const m = log.metrics?.mood ?? 5; 
                            const moodColor = m >= 8 ? 'bg-emerald-400' : m <= 3 ? 'bg-red-400' : 'bg-indigo-400';
                            const activeHabits = Object.keys(log.habits).filter(h => log.habits[h]);
                            return (
                                <div key={log.date} onClick={() => setSelectedEntry(log)} className={`group p-5 rounded-3xl border relative cursor-pointer hover:shadow-lg transition-all bg-white border-slate-100 overflow-hidden`}>
                                    <div className={`absolute left-0 top-0 bottom-0 w-1.5 ${moodColor}`}/>
                                    <div className="flex justify-between items-start mb-3 pl-3">
                                        <div className="flex flex-col"><span className="text-xl font-black text-slate-800 font-mono tracking-tight">{log.date}</span><span className="text-xs text-slate-400 font-bold uppercase tracking-wider">{new Date(log.date).toLocaleDateString('en-US', {weekday:'long'})}</span></div>
                                        <div className="flex flex-col items-end gap-1">
                                            <div className="flex gap-1"><span className={`text-[10px] font-bold px-2 py-0.5 rounded-full flex items-center gap-1 bg-indigo-50 text-indigo-600`}><Activity size={10}/> {m}</span><span className="text-[10px] font-bold px-2 py-0.5 rounded-full flex items-center gap-1 bg-rose-50 text-rose-600"><Zap size={10}/> {log.metrics?.focus}</span></div>
                                            <div className="flex gap-1"><span className="text-[10px] font-bold px-2 py-0.5 rounded-full flex items-center gap-1 bg-amber-50 text-amber-600"><TrendingUp size={10}/> {log.metrics?.energy}</span><span className="text-[10px] font-bold px-2 py-0.5 rounded-full flex items-center gap-1 bg-blue-50 text-blue-600"><Clock size={10}/> {log.metrics?.deepWork}</span></div>
                                        </div>
                                    </div>
                                    <div className="text-sm text-slate-600 font-sans leading-relaxed line-clamp-2 mb-3 pl-3 pr-1">{log.sections?.summary || getPreviewText(log.note)}</div>
                                    <div className="pl-3 flex flex-col gap-2">{isDrift && (<div className="p-2 bg-slate-900 text-white rounded-lg text-xs font-mono flex items-center gap-2 shadow-sm w-fit"><AlertTriangle size={12} className="text-amber-400"/><span className="truncate max-w-[200px]">{insight.text}</span></div>)}{activeHabits.length > 0 && (<div className="flex gap-2 mt-1">{activeHabits.map(h => { const habitConfig = config.habits.find(ch => ch.id === h); if(!habitConfig) return null; const Icon = getIconComponent(habitConfig.icon); return <div key={h} className="text-slate-400 bg-slate-50 p-1 rounded-md"><Icon size={12}/></div> })}</div>)}</div>
                                </div>
                            );
                        })}
                    </div>
                );
            };

            const renderHeader = () => (
                <header className="px-6 py-4 bg-white/90 backdrop-blur z-50 flex justify-between items-center border-b border-slate-200/50 sticky top-0">
                    <div className="flex items-center gap-3">
                        <button onClick={() => setIsMenuOpen(!isMenuOpen)} className="p-2 -ml-2 rounded-xl hover:bg-slate-100 text-slate-600 transition-colors relative"><Menu size={20}/></button>
                        <h1 className="text-lg font-black tracking-tight text-slate-900">LifeOS <span className="text-indigo-600 text-xs align-top">v{VERSION}</span></h1>
                    </div>
                    <div className="w-8 h-8 rounded-full bg-indigo-100 overflow-hidden"><img src={userSettings?.avatar || DEFAULT_SETTINGS.avatar} className="w-full h-full object-cover"/></div>
                    {isMenuOpen && (
                        <>
                            <div className="fixed inset-0 bg-slate-900/20 backdrop-blur-sm z-40" onClick={() => setIsMenuOpen(false)}></div>
                            <div className="absolute top-full left-4 mt-2 w-48 bg-white rounded-2xl shadow-xl border border-slate-100 p-2 z-50 animate-slide-down flex flex-col gap-1">
                                {[ {id:'input', icon:Edit3, label:'Log Entry'}, {id:'graph', icon:Network, label:'Neural Graph'}, {id:'dashboard', icon:Activity, label:'Dashboard'}, {id:'history', icon:Footprints, label:'History'}, {id:'settings', icon:Settings, label:'System'} ].map(item => (
                                    <button key={item.id} onClick={() => { setActiveTab(item.id); setIsMenuOpen(false); }} className={`p-3 rounded-xl flex items-center gap-3 text-sm font-bold transition-all ${activeTab === item.id ? 'bg-indigo-50 text-indigo-600' : 'text-slate-500 hover:bg-slate-50'}`}><item.icon size={16}/> {item.label}</button>
                                ))}
                            </div>
                        </>
                    )}
                </header>
            );

            return (
                <div className="max-w-md mx-auto h-screen bg-slate-50 flex flex-col font-sans text-slate-900 relative shadow-2xl overflow-hidden">
                    <ConfirmModal isOpen={confirmState.isOpen} title={confirmState.title} message={confirmState.message} onConfirm={confirmState.action} onCancel={() => setConfirmState({ ...confirmState, isOpen: false })} />
                    {selectedEntry && (
                        <div className="fixed inset-0 z-[70] flex items-center justify-center p-4 bg-slate-900/60 backdrop-blur-sm animate-fade-in" onClick={() => setSelectedEntry(null)}>
                            <div className="w-full max-w-lg max-h-[85vh] rounded-3xl shadow-2xl overflow-hidden flex flex-col animate-scale-in bg-white" onClick={e=>e.stopPropagation()}>
                                <div className="p-5 border-b border-slate-100 flex justify-between items-center bg-white/95 backdrop-blur sticky top-0 z-10">
                                    <div className="flex flex-col"><h3 className="font-black text-2xl text-slate-800 tracking-tight">{selectedEntry.date}</h3><span className="text-xs font-bold text-slate-400 uppercase tracking-wider">{new Date(selectedEntry.date).toLocaleDateString('en-US', {weekday:'long', month:'short'})}</span></div>
                                    <div className="flex gap-2"><button onClick={() => {copyToClipboard(selectedEntry.note); showToast("Copied")}} className="p-2 bg-slate-50 hover:bg-slate-100 rounded-full text-slate-400 transition-all"><Clipboard size={18}/></button><button onClick={() => requestDelete(selectedEntry.date)} className="p-2 bg-red-50 hover:bg-red-100 text-red-500 rounded-full transition-all"><Trash2 size={18}/></button><button onClick={() => setSelectedEntry(null)} className="p-2 bg-slate-100 hover:bg-slate-200 text-slate-500 rounded-full transition-all"><X size={18}/></button></div>
                                </div>
                                <div className="flex-1 overflow-y-auto custom-scrollbar p-0">
                                    <div className={`h-1.5 w-full ${selectedEntry.metrics.mood > 7 ? 'bg-gradient-to-r from-emerald-400 to-teal-500' : selectedEntry.metrics.mood < 4 ? 'bg-gradient-to-r from-rose-400 to-red-500' : 'bg-gradient-to-r from-indigo-400 to-purple-500'}`} />
                                    {selectedEntry.sections?.summary && (<div className="mx-5 mt-5 p-4 bg-slate-50 rounded-2xl border border-slate-100"><div className="flex items-center gap-2 mb-2 text-slate-400"><Quote size={12} className="fill-current"/><span className="text-[10px] font-bold uppercase tracking-widest">Day Summary</span></div><p className="text-sm font-medium text-slate-700 leading-relaxed italic">"{selectedEntry.sections.summary}"</p></div>)}
                                    <div className="mx-5 mt-4 grid grid-cols-4 gap-2">{[ {l:'Mood', v:selectedEntry.metrics.mood, c:'indigo', i:Activity}, {l:'Focus', v:selectedEntry.metrics.focus, c:'rose', i:Zap}, {l:'Energy', v:selectedEntry.metrics.energy, c:'amber', i:TrendingUp}, {l:'Deep', v:`${selectedEntry.metrics.deepWork}m`, c:'blue', i:Clock} ].map(m => (<div key={m.l} className={`bg-${m.c}-50 rounded-xl p-2 flex flex-col items-center justify-center border border-${m.c}-100`}><m.i size={12} className={`text-${m.c}-500 mb-1`}/><span className={`text-lg font-black text-${m.c}-700`}>{m.v}</span></div>))}</div>
                                    <div className="p-6"><MarkdownRenderer content={selectedEntry.note} /></div>
                                </div>
                            </div>
                        </div>
                    )}
                    <ContextModal mainNode={contextNode} logs={logs} onClose={() => setContextNode(null)} onOpenEntry={(entry) => { setSelectedEntry(entry); }} />
                    {notification && (<div className={`fixed top-6 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded-full text-xs font-bold shadow-xl z-[100] flex items-center gap-2 animate-fade-in-up ${notification.type==='error'?'bg-red-500 text-white':'bg-slate-800 text-white'}`}>{notification.type==='error'?<AlertTriangle size={14}/>:<Check size={14}/>} {notification.msg}</div>)}
                    {renderHeader()}
                    <main className="flex-1 overflow-y-auto p-4 scroll-smooth">
                        {activeTab === 'input' && renderInputTab()}
                        {activeTab === 'graph' && (
                            <div className="space-y-4 animate-fade-in h-full flex flex-col">
                                <div className="bg-white p-4 rounded-3xl shadow-sm border border-slate-100 flex-1 flex flex-col"><h3 className="text-sm font-bold text-slate-700 mb-4 flex items-center gap-2"><Network className="w-4 h-4 text-indigo-500"/> ÁÑ°ÈôêÂúñË≠ú (Infinite Graph)</h3><div className="flex-1 rounded-2xl overflow-hidden border border-slate-100 bg-slate-50 relative"><NeuralGraph logs={logs} onNodeClick={setContextNode} /></div><p className="text-center text-[10px] text-slate-400 mt-2">ÊªæËº™Á∏ÆÊîæ ‚Ä¢ ÊãñÊõ≥ÁßªÂãï ‚Ä¢ ÈªûÊìäÁØÄÈªû</p></div>
                            </div>
                        )}
                        {activeTab === 'dashboard' && renderDashboard()}
                        {activeTab === 'history' && renderHistoryView()}
                        {activeTab === 'settings' && renderSettingsView()}
                    </main>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<LifeOS />);
    </script>
</body>
</html>
